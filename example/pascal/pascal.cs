// parser.cs

// DO NOT EDIT THIS FILE
// This file was generated using the Human Parser Generator (https://github.com/christophevg/human-parser-generator)


using System;
using System.IO;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Linq;
using System.Diagnostics;


public class Program {
  public Identifier Identifier { get; set; }
  public List<Assignment> Assignments { get; set; }
  public Program() {
    this.Assignments = new List<Assignment>();
  }
  public override string ToString() {
    return
    "Program(" +
    "Identifier=" + this.Identifier + "," +
    "Assignments=" + "[" +
    string.Join(",", this.Assignments.Select(x => x.ToString())) +
    "]" +
    ")";
  }
}

public class Assignment {
  public Identifier Identifier { get; set; }
  public Expression Expression { get; set; }
  public override string ToString() {
    return
    "Assignment(" +
    "Identifier=" + this.Identifier + "," +
    "Expression=" + this.Expression +
    ")";
  }
}

public interface Expression {}

public class Identifier : Expression {
  public string Name { get; set; }
  public override string ToString() {
    return
    "Identifier(" +
    "Name=" + this.Name +
    ")";
  }
}

public class String : Expression {
  public string Text { get; set; }
  public override string ToString() {
    return
    "String(" +
    "Text=" + this.Text +
    ")";
  }
}

public class Number : Expression {
  public string Value { get; set; }
  public override string ToString() {
    return
    "Number(" +
    "Value=" + this.Value +
    ")";
  }
}

public class Parser {
  public Parsable Source { get; private set; }
  public Program AST { get; set; }
  public List<ParseException> Errors = new List<ParseException>();

  private bool Consume(string text) {
    return this.Source.Consume(text);
  }

  private bool MaybeConsume(string text) {
    return this.Source.TryConsume(text);
  }

  private  string Consume(Regex pattern) {
    return this.Source.Consume(pattern);
  }

  private void Maybe(Action what) {
    int pos = this.Source.Position;
    try {
      what();
    } catch {
      this.Source.Position = pos;
    }
  }

  public class Outcome {
    public Parser Parser { get; set; }
    public bool Success { get; set; }
    public ParseException Exception { get; set; }

    public Outcome Or(Action what) {
      if( ! this.Success ) {
        return this.Parser.Parse(what);
      }
      return this;
    }

    public Outcome OrThrow(string message) {
      if( ! this.Success ) {
        throw this.Parser.Source.GenerateParseException(message);
      }
      return this;
    }
  }

  public Outcome Parse(Action what) {
    int pos = this.Source.Position;
    try {
      what();
    } catch(ParseException e) {
      this.Source.Position = pos;
      return new Outcome() {
        Success   = false,
        Exception = e,
        Parser    = this
      };
    }
    return new Outcome() {
      Success = true,
      Parser  = this
    };
  }

  private List<T> Many<T>(Func<T> what) {
    List<T> list = new List<T>();
    while(true) {
      try {
        list.Add(what());
      } catch(ParseException e) {
        // add the error to the errors list, because we shadow it
        // it still might be the best we've got ;-)
        this.Errors.Add(e);
        break;
      }
    }
    return list;
  }

  public Parser Parse(string source) {
    this.Source = new Parsable(source);
    try {
      this.AST = this.ParseProgram();
    } catch(ParseException e) {
      this.Errors.Add(e);
      throw this.Source.GenerateParseException("Failed to parse.");
    }
    if( ! this.Source.IsDone ) {
      throw this.Source.GenerateParseException("Could not parse remaining data.");
    }
    return this;
  }

  public Program ParseProgram() {
    Identifier identifier = null;
    List<Assignment> assignments = new List<Assignment>();
    this.Log( "ParseProgram" );
    Parse( () => {
      Consume("PROGRAM");
      identifier = ParseIdentifier();
      Consume("BEGIN");
      assignments = Many<Assignment>(ParseAssignment);
      Consume("END.");
    }).OrThrow("Failed to parse Program.");
    return new Program() {
      Identifier = identifier,
      Assignments = assignments
    };
  }

  public Assignment ParseAssignment() {
    Identifier identifier = null;
    Expression expression = null;
    this.Log( "ParseAssignment" );
    Parse( () => {
      identifier = ParseIdentifier();
      Consume(":=");
      expression = ParseExpression();
      Consume(";");
    }).OrThrow("Failed to parse Assignment.");
    return new Assignment() {
      Identifier = identifier,
      Expression = expression
    };
  }

  public Expression ParseExpression() {
    Expression alternative = null;
    this.Log( "ParseExpression" );
    Parse( () => {
      Parse( () => {
        alternative = ParseIdentifier();
      })
      .Or( () => {
        alternative = ParseString();
      })
      .Or( () => {
        alternative = ParseNumber();
      })
      .OrThrow("Expected: identifier | string | number");
    }).OrThrow("Failed to parse Expression.");
    return alternative;
  }

  public Identifier ParseIdentifier() {
    string name = null;
    this.Log( "ParseIdentifier" );
    Parse( () => {
      name = Consume(Extracting.Identifier);
    }).OrThrow("Failed to parse Identifier.");
    return new Identifier() {
      Name = name
    };
  }

  public String ParseString() {
    string text = null;
    this.Log( "ParseString" );
    Parse( () => {
      text = Consume(Extracting.String);
    }).OrThrow("Failed to parse String.");
    return new String() {
      Text = text
    };
  }

  public Number ParseNumber() {
    string value = null;
    this.Log( "ParseNumber" );
    Parse( () => {
      value = Consume(Extracting.Number);
    }).OrThrow("Failed to parse Number.");
    return new Number() {
      Value = value
    };
  }


  [ConditionalAttribute("DEBUG")]
  private void Log(string msg) {
    Console.Error.WriteLine("!!! " + msg + " @ " + this.Source.Peek(10).Replace('\n', 'n'));
  }
}

public class Extracting {
  public static Regex Identifier = new Regex(@"^([A-Z][A-Z0-9]*)");
  public static Regex String     = new Regex(@"^""([^""]*)""|'([^']*)'");
  public static Regex Number     = new Regex(@"^(-?[1-9][0-9]*)");
}
