(* DB2 DDL gammar for Human Parser Generator                            *)
(* https://github.com/christophevg/human-parser-generator               *)
(* author: Christophe VG <contact@christophe.vg>                        *)
(* This grammar is not based on an official grammar!                    *)
(* It has been assembled to be able to parse a given set of DDL files.  *)

ddl                           ::= { statement } ;

statement                     ::= comment
                                | create-statement
                                | set-statement
                                | alter-statement
                                ;

comment                       ::= message @ ? /--([^\n]*)/ ? ;

(* CREATE ... *)

create-statement              ::= "CREATE" 
                                  ( create-database-statement
                                  | create-tablespace-statement
                                  | create-table-statement
                                  | create-index-statement
                                  | create-view-statement
                                  )
                                  ";"
                                ;

create-database-statement     ::= ( _ @ "DATABASE" | _ @ "DB" ) name @ fqn
                                  { parameter @ database-parameter }
                                ;

create-tablespace-statement   ::= "TABLESPACE" name @ fqn
                                  "IN" database @ fqn
                                  { parameter @ tablespace-parameter }
                                ;

create-table-statement        ::= "TABLE" name @ fqn "(" element-list ")"
                                  "IN" database @ fqn
                                  { parameter @ table-parameter }
                                ;

create-index-statement        ::= [ "UNIQUE" ] "INDEX" name @ fqn "ON" table @ fqn
                                  "(" columns @ index-column-list ")"
                                  { parameter @ index-parameter }
                                ;

index-column-list             ::= index-column { "," index-column } ;
index-column                  ::= column @ identifier [ "ASC" | "DESC" ];

create-view-statement         ::= "VIEW" name @ fqn "AS" definition @ raw-ddl;

element-list                  ::= element { _ @ "," element } ;
element                       ::= constraint-definition | column-definition ;

constraint-definition         ::= "CONSTRAINT" name @ identifier constraint ;

constraint                    ::= primary-key-constraint
                                | foreign-key-constraint
                                | check-constraint
                                ;

primary-key-constraint        ::= "PRIMARY" "KEY" "(" column-list ")" ;

foreign-key-constraint        ::= "FOREIGN" "KEY" "(" keys @ column-list ")"
                                  "REFERENCES" table @ fqn
                                  "(" references @ column-list ")"
                                  { parameter @ foreign-key-parameter }
                                ;

(* TODO convert to actual parsing logic in stead of grab-all *)
check-constraint              ::= "CHECK" "(" rule ")";
rule                          ::= ? /([^\)]*?)(?<keep>\))/ ? ;

column-definition             ::= name @ fqn data-type { column-config } ;

data-type                     ::= type @ identifier
                                  [ "(" length @ number [ "," decimal-length @ number ] ")" ]
                                ;

column-config                 ::= constraint-definition | column-parameter ;

column-parameter              ::= not-null @ "NOT NULL"
                                | "FOR" for @ identifier _ @ "DATA"
                                | "WITH DEFAULT" [ default-value @ literal ]
                                ;

(* SET ... *)

set-statement                 ::= "SET" set-parameter "=" value @ raw-ddl ";" ;

set-parameter                 ::= "CURRENT PATH" ;

(* ALTER ... *)

alter-statement               ::= "ALTER" alter-table ";" ;

alter-table                   ::= "TABLE" name @ fqn add-statement ;

add-statement                 ::= "ADD" { constraint-definition } ;

(* general purpose rules *)

literal                       ::= string | number ;

(* TODO split out into different parameter sets *)

database-parameter           ::= buffer-pool-parameter
                               | indexbp-parameter
                               | sto-group-parameter
                               | ccsid-parameter
                               ;

tablespace-parameter         ::= sto-group-parameter
                               | priqty-parameter
                               | secqty-parameter
                               | erase-parameter
                               | free-page-parameter
                               | pct-free-parameter
                               | gbp-cache-parameter
                               |  compress-parameter
                               | track-mod-parameter
                               |  logged-parameter
                               | ds-size-parameter
                               | seg-size-parameter
                               | max-partitions-parameter
                               | buffer-pool-parameter
                               | lock-size-parameter
                               | lock-max-parameter
                               | close-parameter
                               | ccsid-parameter
                               | max-rows-parameter
                               ;

table-parameter              ::= data-capture-parameter
                               | ccsid-parameter
                               | volatile-parameter
                               | append-parameter
                               ;

index-parameter              ::= sto-group-parameter
                               | priqty-parameter
                               | secqty-parameter
                               | erase-parameter
                               | free-page-parameter
                               | pct-free-parameter
                               | gbp-cache-parameter
                               | cluster-parameter
                               | buffer-pool-parameter
                               | close-parameter
                               | copy-parameter
                               | piece-size-parameter
                               | compress-parameter
                               | include-parameter
                               ;

foreign-key-parameter        ::= on-delete-parameter
                               | enforced-parameter
                               ;

append-parameter             ::= "APPEND" append @ boolean ;
buffer-pool-parameter        ::= "BUFFERPOOL" bufferpool @ identifier ;
ccsid-parameter              ::= "CCSID" ccsid @ identifier ;
close-parameter              ::= "CLOSE" close @ boolean ;
cluster-parameter            ::= [ "NOT" ] "CLUSTER" ;
copy-parameter               ::= "COPY" copy @ boolean ;
compress-parameter           ::= "COMPRESS" compress @ boolean ;
data-capture-parameter       ::= "DATA CAPTURE" data-capture @ identifier ;
ds-size-parameter            ::= "DSSIZE" dssize @ number _ @ "G" ;
enforced-parameter           ::= "ENFORCED" ;
erase-parameter              ::= "ERASE" erase @ boolean ;
free-page-parameter          ::= "FREEPAGE" freepage @ number ;
gbp-cache-parameter          ::= "GBPCACHE" gbpcache @ identifier ;
include-parameter            ::= "INCLUDE" "(" column @ identifier ")" ;
indexbp-parameter            ::= "INDEXBP" index @ identifier;
lock-max-parameter           ::= "LOCKMAX" lockmax @ identifier ;
lock-size-parameter          ::= "LOCKSIZE" locksize @ identifier ;
logged-parameter             ::= "LOGGED" ;
max-partitions-parameter     ::= "MAXPARTITIONS" maxpartitions @ number ;
max-rows-parameter           ::= "MAXROWS" maxrows @ number ;
on-delete-parameter          ::= "ON DELETE" ( "RESTRICT" | "SET NULL" ) ;
pct-free-parameter           ::= "PCTFREE" pctfree @ number ;
piece-size-parameter         ::= "PIECESIZE" size @ number "G" ;
priqty-parameter             ::= "PRIQTY" priqty @ number ;
secqty-parameter             ::= "SECQTY" secqty @ number ;
seg-size-parameter           ::= "SEGSIZE" segsize @ number ;
sto-group-parameter          ::= [ _ @ "USING" ] "STOGROUP" sto-group @ identifier ;
track-mod-parameter          ::= "TRACKMOD" trackmod @ boolean ;
volatile-parameter           ::= [ "NOT" ] "VOLATILE" ;

fqn                          ::= [ scope @ identifier _ @ "." ] name @ identifier ;

column-list                  ::= column @ identifier { _ @ "," column @ identifier } ;

identifier                   ::= name  @ ? /([\w]+)/ ? ;
number                       ::= value @ ? /([0-9\\.]+)/ ? ;
string                       ::= text  @ ? /"([^"]*)"|^'([^']*)'/ ? ;
boolean                      ::= value @ ? /(YES|yes|TRUE|True|true|NO|no|FALSE|False|false)/ ? ;

raw-ddl                      ::= ? /([^;]*)/ ? ;
