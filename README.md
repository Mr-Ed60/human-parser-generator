# Human Parser Generator

A simple Parser Generator with a focus on "human" code generation    
Christophe VG (<contact@christophe.vg>)  
[https://github.com/christophevg/cs-parser-generator](https://github.com/christophevg/cs-parser-generator)

# Introduction

Although many parser generators exist, I feel like there is room for one more, which generates a parser in a more human way.

The objectives are:

* start from an EBNF-like notation, e.g. allow copy pasting existing grammars and (maybe) be done with it.
* generate code, as if it were written by a human developer:
	* generate functional classes to construct an AST
	* generate parser logic that is readable and understandable
* be self hosting: the project should be able to generate itself.

The project will initially target C#. No other target language is planned at this point.

**Disclaimer** I'm not aiming for feature completeness and only add support for what I need at a given time ;-) Current status: A trivial example of a small subset of the Pascal language can be parsed. Next step is the generation of the EBNF-like parser, aka being self hosting.

## Example

The following example is taken from [the Wikipedia page on EBNF](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form):

```ebnf
(* a simple program syntax in EBNF − Wikipedia *)
 program = 'PROGRAM', white space, identifier, white space, 
            'BEGIN', white space, 
            { assignment, ";", white space }, 
            'END.' ;
 identifier = alphabetic character, { alphabetic character | digit } ;
 number = [ "-" ], digit, { digit } ;
 string = '"' , { all characters - '"' }, '"' ;
 assignment = identifier , ":=" , ( number | identifier | string ) ;
 alphabetic character = "A" | "B" | "C" | "D" | "E" | "F" | "G"
                      | "H" | "I" | "J" | "K" | "L" | "M" | "N"
                      | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
                      | "V" | "W" | "X" | "Y" | "Z" ;
 digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
 white space = ? white space characters ? ;
 all characters = ? all visible characters ? ;
```

This grammar would allow to parse

```pascal
 PROGRAM DEMO1
 BEGIN
   A:=3;
   B:=45;
   H:=-100023;
   C:=A;
   D123:=B34A;
   BABOON:=GIRAFFE;
   TEXT:="Hello world!";
 END.
```

### Changes, Simplifications, Extensions,...

To get a head-start I've added few changes/extensions/limitations to the standard EBNF notation. The following grammar is a rewritten version of the earlier example, using these extensions:

```ebnf
program = 'PROGRAM', identifier, 
          'BEGIN', 
          { assignment }, 
          'END.' ;
assignment = identifier , ":=" , ( number | identifier | string ), ";";
identifier = /([A-Z][A-Z0-9]*)/;
number     = /(-?[1-9][0-9]*)/ ;
string     = /"([^"]*)"/;
```

The extensions that are applied are:

* ignoring whitespace, removing the need for explicit whitespace description
* definition of "extracting terminals" using regular expressions

### Demo

In the `example/` folder I've started by writing a manual implementation, taking into account how I think this could be generated. In the `generator/` folder a first (very rough) implementation of the generator is able to generate the same parser from a `Grammar` `Model`.

The Makefile implements a complete demo that first generates the parser, compares the generated version to the manual version (not taking into account whitespace changes ;-) ) and then copies the other files from the demo (`parsable.cs`, which contains a helper class to deal with basic parsing operation, `main.cs`, the same runner, `example.pascal`, the Pascal source code and `Makefile`, to compile and run the parser).

```bash
$ cd generator/
$ make demo
*** generating parser
*** comparing to manual version
*** adding parsable and supporting files
*** running example with generated code
Program(Identifier=DEMO1,Assignments=[Assignment(Identifier=A,Value=3),Assignment(Identifier=B,Value=45),Assignment(Identifier=H,Value=-100023),Assignment(Identifier=C,Value=A),Assignment(Identifier=D123,Value=B34A),Assignment(Identifier=BABOON,Value=GIRAFFE),Assignment(Identifier=TEXT,Value=Hello world!)])
```

## Being Self Hosting

The next important step is being self hosting and parsing the EBNF-like grammars with a parser that is generated by the parser generator itself.

The grammar for the EBNF-like notation looks like this:

```
identifier = /([A-Z][A-Z0-9]*)/;
number     = /(-?[1-9][0-9]*)/ ;
string     = /"([^"]*)"/;

expression = identifier
          | string
          | "[" , expression , "]"
          | "{" , expression , "}"
          | "(" , expression , ")"
          | expression , "|" , expression
          | expression , "," , expression ;
rule = identifier , "=" , expression , ";" ;
grammar = { rule } ;
```

The current manual implementation of the required Model doesn't even match this notation yet. It would require further rewriting, mostly expanding the different expressions to explicitly named. This is a work in progress that's currently being focused on.
