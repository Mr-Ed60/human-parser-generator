# Human Parser Generator

A simple Parser Generator with a focus on "human" code generation    
Christophe VG (<contact@christophe.vg>)  
[https://github.com/christophevg/cs-parser-generator](https://github.com/christophevg/cs-parser-generator)

# Introduction

Although many parser generators exist, I feel like there is room for one more, which generates a parser in a more human way.

The objectives are:

* start from an EBNF-like notation, e.g. allow copy pasting existing grammars and (maybe) be done with it.
* generate code, as if it were written by a human developer:
	* generate functional classes to construct an AST
	* generate parser logic that is readable and understandable
* be self hosting: the project should be able to generate itself.

The project will initially target C#. No other target language is planned at this point.

**Disclaimer** I'm not aiming for feature completeness and only add support for what I need at a given time ;-) Current status: A trivial example of a small subset of the Pascal language can be parsed. Next step is the generation of the EBNF-like parser, aka being self hosting.

## Example

The following example is taken from [the Wikipedia page on EBNF](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form):

```ebnf
(* a simple program syntax in EBNF − Wikipedia *)
 program = 'PROGRAM', white space, identifier, white space, 
            'BEGIN', white space, 
            { assignment, ";", white space }, 
            'END.' ;
 identifier = alphabetic character, { alphabetic character | digit } ;
 number = [ "-" ], digit, { digit } ;
 string = '"' , { all characters - '"' }, '"' ;
 assignment = identifier , ":=" , ( number | identifier | string ) ;
 alphabetic character = "A" | "B" | "C" | "D" | "E" | "F" | "G"
                      | "H" | "I" | "J" | "K" | "L" | "M" | "N"
                      | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
                      | "V" | "W" | "X" | "Y" | "Z" ;
 digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
 white space = ? white space characters ? ;
 all characters = ? all visible characters ? ;
```

This grammar would allow to parse

```pascal
 PROGRAM DEMO1
 BEGIN
   A:=3;
   B:=45;
   H:=-100023;
   C:=A;
   D123:=B34A;
   BABOON:=GIRAFFE;
   TEXT:="Hello world!";
 END.
```

### Changes, Simplifications, Extensions,...

To get a head-start I've added few changes/extensions/limitations to the standard EBNF notation. The following grammar is a rewritten version of the earlier example, using these extensions:

```ebnf
program    ::= "PROGRAM" identifier
               "BEGIN"
               { assignment }
               "END."
               ;

assignment ::= identifier
               ":="
               ( number | identifier | string )
               ";"
               ;

identifier       ::= /([A-Z][A-Z0-9]*)/ ;
number           ::= /(-?[1-9][0-9]*)/ ;
string           ::= /"([^"]*)"|'([^']*)'/ ;
```

The extensions that are applied are:

* abandoned `,` (colon) in sequences of consecutive expressions
* ignoring whitespace, removing the need for explicit whitespace description
* definition of "extracting terminals" using regular expressions

### Demo

In the `example/` folder I've started by writing a manual implementation (`parser.cs`), taking into account how I think this could be generated. The output of the example program, parses the example Pascal file and outputs an AST-like structure:

```bash
$ cd example
$ make
Program(Identifier=DEMO1,Assignments=[Assignment(Identifier=A,Value=3),Assignment(Identifier=B,Value=45),Assignment(Identifier=H,Value=-100023),Assignment(Identifier=C,Value=A),Assignment(Identifier=D123,Value=B34A),Assignment(Identifier=BABOON,Value=GIRAFFE),Assignment(Identifier=TEXT,Value=Hello world!)])
```

In the `generator/` folder a first (very rough) implementation of the generator is able to generate the same parser from a `Grammar` `Model`.

The Makefile implements a complete demo that first generates the parser, compares the generated version to the manual version (not taking into account whitespace changes ;-) ) and then copies the other files from the demo (`parsable.cs`, which contains a helper class to deal with basic parsing operation, `main.cs`, the same runner, `example.pascal`, the Pascal source code and `Makefile`, to compile and run the parser).

```bash
$ cd generator/
$ make
*** comparing to manual version
*** setting up runtime environment for parser
*** running example with generated code
Program(Identifier=DEMO1,Assignments=[Assignment(Identifier=A,Value=3),Assignment(Identifier=B,Value=45),Assignment(Identifier=H,Value=-100023),Assignment(Identifier=C,Value=A),Assignment(Identifier=D123,Value=B34A),Assignment(Identifier=BABOON,Value=GIRAFFE),Assignment(Identifier=TEXT,Value=Hello world!)])
```

## Being Self Hosting

The next important step is being self hosting and parsing the EBNF-like grammars with a parser that is generated by the parser generator itself.

The grammar for the Human Parser Generator BNF-like notation (currently) looks like this - but this is a work in progress:

```ebnf
grammar                 ::= { rule } ;

rule                    ::= identifier "::=" expression-list ";" ;

expression-list         ::= alternatives-expression
                          | sequence-expression
                          ;

alternatives-expression ::= expression "|" expression-list ;
sequence-expression     ::= { expression } ;

expression              ::= string-expression
                          | extractor-expression
                          | optional-expression
                          | repetition-expression
                          | group-expression
                          | or-expression
                          | identifier-expression
                          ;
string-expression       ::= string ;
extractor-expression    ::= "/" regex "/" ;
optional-expression     ::= "[" expression-list "]" ;
repetition-expression   ::= "{" expression-list "}" ;
group-expression        ::= "(" expression-list ")" ;
identifier-expression   ::= identifier ;

identifier              ::= /([A-Za-z][A-Z0-9a-z-]*)/ ;
string                  ::= /"([^"]*)"|^'([^']*)'/ ;
regex                   ::= /([^/]*)/ ;
```

Until the parser can be generated, the bootstrapping source for this grammar is stored in `generator/grammar.cs` in the `AsModel` class, retrievable via the `BNF()` static method.

### Test Driven

To be able to focus on sub-problems and isolate combinations of constructs, I've set up a unit testing infrastructure that generates a parser and then uses that to run the tests:

```bash
$ make
*** generating HPG BNF-like parser...
*** building unit tests
*** executing unit tests
.
Tests run: 1, Failures: 0, Not run: 0, Time: 0.087 seconds
```
